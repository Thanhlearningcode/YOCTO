[{"id": "content/1-gi-i-thi-u-v-yocto-project.md", "title": "Tầm quan trọng của Yocto trong phát triển nhúng", "body": "# Tầm quan trọng của Yocto trong phát triển nhúng\n\nYocto Project giúp giải quyết một số vấn đề chính trong phát triển hệ điều hành cho thiết bị nhúng:\n\n- **Tính linh hoạt**: Yocto cho phép tùy chỉnh từ bootloader, kernel đến user space, từ đó dễ dàng tạo ra hệ điều hành phù hợp cho các thiết bị có yêu cầu phần cứng riêng biệt.  \n- **Tái sử dụng mã nguồn**: Yocto hỗ trợ việc tái sử dụng các thành phần từ các dự án mã nguồn mở, giúp tiết kiệm thời gian và chi phí phát triển.  \n- **Khả năng mô đun hóa**: Với các meta-layer và recipe, Yocto giúp quản lý, mở rộng và phát triển hệ thống một cách hiệu quả, tách biệt các thành phần theo từng lớp chức năng.  \n- **Khả năng tích hợp CI/CD**: Yocto có thể tích hợp với các hệ thống Continuous Integration/Continuous Deployment (CI/CD) để giúp tự động hóa và kiểm tra quá trình xây dựng hệ điều hành.  \n\n---\n\n# Các thành phần chính của Yocto Project\n\n## 2.1. BitBake\nBitBake là công cụ chính trong Yocto Project được sử dụng để quản lý và thực hiện việc build hệ điều hành. Nó có nhiệm vụ xử lý các recipes (công thức xây dựng phần mềm), điều phối việc biên dịch mã nguồn, tạo hệ thống tập tin, và các thành phần khác của hệ điều hành.\n\n- **Quản lý Dependency**: BitBake xác định các phụ thuộc giữa các thành phần và đảm bảo chúng được xây dựng đúng thứ tự.  \n- **Tính module hóa**: BitBake hỗ trợ việc xây dựng hệ điều hành dưới dạng module, dễ dàng thêm, loại bỏ hoặc thay đổi các thành phần.  \n\n## 2.2. Recipe\nRecipe là các tệp tin mô tả cách biên dịch và cài đặt một gói phần mềm trong Yocto Project. Mỗi recipe chứa các hướng dẫn như:\n\n- Nguồn mã nguồn (**SRC_URI**)  \n- Cách biên dịch (**do_compile**)  \n- Cách cài đặt (**do_install**)  \n\nCác recipe có phần mở rộng `.bb` và là thành phần quan trọng giúp BitBake hiểu cách biên dịch một phần mềm.\n\n## 2.3. Layer (meta layer)\nLayers (meta-layers) là cách Yocto Project tổ chức và quản lý các thành phần của hệ điều hành. Mỗi layer chứa các recipe, patch, và cấu hình liên quan đến một bộ chức năng hoặc một loại phần cứng cụ thể.\n\n- **Meta-layer**: Có thể chứa cấu hình phần cứng (vd: meta-raspberrypi), phần mềm (vd: meta-openembedded), hoặc layer riêng của dự án.  \n- **Layer Priority**: Yocto cho phép sắp xếp ưu tiên các layer để ghi đè hoặc mở rộng các thành phần.  \n\n## 2.4. Config File\nConfig file gồm các tệp cấu hình thiết lập môi trường build:  \n\n- **local.conf**: Thiết lập liên quan đến máy đích, số luồng CPU để build, ...  \n- **bblayers.conf**: Xác định các layer mà BitBake sẽ sử dụng trong quá trình build.  \n\n## 2.5. Metadata\nMetadata chứa tất cả thông tin và chỉ thị về cách biên dịch và cấu trúc hệ điều hành. Metadata có thể nằm trong recipe, layer, và các tệp cấu hình khác.\n\n## 2.6. Class\nClass (`.bbclass`) chứa các đoạn mã dùng chung để sử dụng trong nhiều recipe. Ví dụ: `autotools.bbclass` cung cấp lệnh để build phần mềm dùng autotools.\n\n## 2.7. BitBake File\nBitBake file là các tệp recipe với phần mở rộng `.bb`. Các file `.bbappend` có thể mở rộng hoặc ghi đè recipe sẵn có.\n\n## 2.8. Package\nPackage là kết quả đầu ra của quá trình biên dịch trong Yocto. BitBake sẽ tạo package dưới dạng `.ipk`, `.deb`, hoặc `.rpm`.\n\n## 2.9. OpenEmbedded\nOpenEmbedded là framework cơ bản mà Yocto Project sử dụng, cung cấp meta-layers, recipes và thư viện phong phú để xây dựng gói phần mềm.\n\n---\n\n# 3. Kết luận\nYocto Project là công cụ quan trọng trong phát triển hệ điều hành nhúng. Các thành phần như Poky, BitBake, layer và recipe giúp quản lý hệ thống có tổ chức, dễ tùy chỉnh, phù hợp cho từng yêu cầu phần cứng và phần mềm của thiết bị nhúng.\n"}, {"id": "content/10-c-c-l-i-th-ng-g-p-khi-ph-t-tri-n-v-i-yocto-project-v-c-ch-kh-c-ph-c.md", "title": "Kiểm tra locale hiện tại", "body": "Yocto Project là một công cụ mạnh mẽ để xây dựng hệ thống Linux tùy chỉnh cho các thiết bị nhúng. Tuy nhiên, do tính phức tạp và sự phụ thuộc vào nhiều thành phần, các nhà phát triển thường gặp phải nhiều loại lỗi khác nhau. Bài viết này sẽ phân tích các lỗi phổ biến nhất khi làm việc với Yocto Project và cung cấp hướng dẫn chi tiết để khắc phục chúng.\n\n1. Lỗi thiết lập môi trường\n1.1. Lỗi \"Command not found\" khi chạy bitbake\nTriệu chứng:\n\n$ bitbake core-image-minimal\nbash: bitbake: command not found\n📋 Copy\nNguyên nhân: Môi trường Yocto chưa được thiết lập đúng cách.\n\nGiải pháp:\n\n$ source oe-init-build-env [build-directory]\n📋 Copy\n1.2. Lỗi \"Please use a locale setting which supports UTF-8\"\nTriệu chứng:\n\nPlease use a locale setting which supports UTF-8 (such as LANG=en_US.UTF-8).\nPython can't change the filesystem locale after loading so we need a UTF-8\nlocale before startup.\n📋 Copy\nNguyên nhân: Cài đặt locale không hỗ trợ UTF-8.\n\nGiải pháp:\n\n# Kiểm tra locale hiện tại\nlocale\n\n# Thiết lập locale UTF-8\nexport LC_ALL=en_US.UTF-8\nexport LANG=en_US.UTF-8\n\n# Nếu locale chưa được cài đặt\nsudo apt-get install locales\nsudo locale-gen en_US.UTF-8\n📋 Copy\n1.3. Lỗi Python không tương thích\nTriệu chứng:\n\nThis program requires Python 3.6.0 or greater\n📋 Copy\nNguyên nhân: Phiên bản Python không tương thích với Yocto.\n\nGiải pháp:\n\n# Kiểm tra phiên bản Python\npython3 --version\n\n# Cài đặt phiên bản Python phù hợp\nsudo apt-get install python3.8 python3.8-dev\n📋 Copy\n2. Lỗi tải mã nguồn (Fetching)\n2.1. Lỗi tải mã nguồn từ Git\nTriệu chứng:\n\nERROR: Fetcher failure: Unable to find revision abcdef1234567890 in branch master even from upstream\n📋 Copy\nNguyên nhân: Không thể tìm thấy commit cụ thể hoặc kết nối mạng có vấn đề.\n\nGiải pháp:\n\n# Kiểm tra kết nối đến repository\ngit ls-remote <repository-url>\n\n# Cập nhật SRCREV trong recipe\nSRCREV = \"latest-commit-hash\"\n\n# Hoặc sử dụng AUTOREV (không nên dùng cho production)\nSRCREV = \"${AUTOREV}\"\n📋 Copy\n2.2. Lỗi tải tệp từ HTTP/FTP\nTriệu chứng:\n\nERROR: Fetcher failure for URL: 'http://example.com/package-1.0.tar.gz'. Unable to fetch URL\n📋 Copy\nNguyên nhân: URL không tồn tại, máy chủ không phản hồi, hoặc vấn đề mạng.\n\nGiải pháp:\n\n# Kiểm tra URL trong trình duyệt\n# Thay đổi URL trong recipe\nSRC_URI = \"http://mirror-site.com/package-1.0.tar.gz\"\n\n# Hoặc sử dụng bản sao cục bộ\nSRC_URI = \"file://local-path/package-1.0.tar.gz\"\n📋 Copy\n2.3. Lỗi checksum\nTriệu chứng:\n\nERROR: Checksum mismatch for local file download:/path/to/file.tar.gz\n📋 Copy\nNguyên nhân: Tệp đã tải xuống không khớp với checksum đã khai báo.\n\nGiải pháp:\n\n# Cập nhật checksum trong recipe\nSRC_URI[md5sum] = \"new-md5-checksum\"\nSRC_URI[sha256sum] = \"new-sha256-checksum\"\n\n# Hoặc tính toán checksum mới\nmd5sum file.tar.gz\nsha256sum file.tar.gz\n📋 Copy\n3. Lỗi biên dịch (Compilation)\n3.1. Lỗi biên dịch C/C++\nTriệu chứng:\n\nERROR: Function failed: do_compile\n| /path/to/file.c:123:45: error: 'struct example' has no member named 'member'\n📋 Copy\nNguyên nhân: Lỗi cú pháp, thư viện thiếu, hoặc không tương thích.\n\nGiải pháp:\n\n# Kiểm tra log chi tiết\nless tmp/work/<package-path>/temp/log.do_compile\n\n# Thêm patch để sửa lỗi\nSRC_URI += \"file://0001-Fix-compilation-error.patch\"\n\n# Thêm cờ biên dịch\nTARGET_CFLAGS += \"-Ddefine_macro\"\n\n# Thêm thư viện phụ thuộc\nDEPENDS += \"required-library\"\n📋 Copy\n3.2. Lỗi autotools\nTriệu chứng:\n\nERROR: Function failed: do_configure\n| configure: error: cannot find install-sh, install.sh, or shtool\n📋 Copy\nNguyên nhân: Cấu hình autotools không chính xác.\n\nGiải pháp:\n\n# Thêm cờ cấu hình\nEXTRA_OECONF += \"--with-feature --disable-option\"\n\n# Chạy autoreconf\ndo_configure_prepend() {\n    cd ${S}\n    autoreconf -fi\n}\n📋 Copy\n3.3. Lỗi CMake\nTriệu chứng:\n\nERROR: Function failed: do_configure\n| CMake Error: Could not find module FindSomeLibrary.cmake\n📋 Copy\nNguyên nhân: Thiếu module CMake hoặc cấu hình không chính xác.\n\nGiải pháp:\n\n# Thêm cờ CMake\nEXTRA_OECMAKE += \"-DENABLE_FEATURE=ON -DDISABLE_OPTION=OFF\"\n\n# Cung cấp module bị thiếu\ndo_configure_prepend() {\n    cp ${WORKDIR}/FindSomeLibrary.cmake ${S}/cmake/modules/\n}\n📋 Copy\n4. Lỗi cấu hình (Configuration)\n4.1. Lỗi MACHINE không xác định\nTriệu chứng:\n\nERROR: Unable to parse /path/to/conf/local.conf: Could not find a valid MACHINE assignment\n📋 Copy\nNguyên nhân: Biến MACHINE không được đặt hoặc không hợp lệ.\n\nGiải pháp:\n\n# Chỉnh sửa conf/local.conf\nMACHINE ?= \"qemux86-64\"  # hoặc máy đích khác\n\n# Kiểm tra các máy có sẵn\nls meta*/conf/machine/*.conf\n📋 Copy\n4.2. Lỗi layer không tìm thấy\nTriệu chứng:\n\nERROR: Layer 'meta-custom' not found in the repository\n📋 Copy\nNguyên nhân: Layer không tồn tại hoặc chưa được thêm vào bblayers.conf.\n\nGiải pháp:\n\n# Kiểm tra các layer đã cài đặt\nbitbake-layers show-layers\n\n# Thêm layer mới\nbitbake-layers add-layer /path/to/meta-custom\n\n# Hoặc chỉnh sửa conf/bblayers.conf thủ công\nBBLAYERS += \"/path/to/meta-custom\"\n📋 Copy\n4.3. Lỗi biến không xác định\nTriệu chứng:\n\nERROR: Parsing halted due to errors. The variable UNDEFINED_VARIABLE is not defined\n📋 Copy\nNguyên nhân: Biến được sử dụng nhưng không được định nghĩa.\n\nGiải pháp:\n\n# Định nghĩa biến trong recipe\nUNDEFINED_VARIABLE = \"value\"\n\n# Hoặc trong local.conf\nUNDEFINED_VARIABLE ?= \"value\"\n📋 Copy\n5. Lỗi phụ thuộc (Dependencies)\n5.1. Lỗi thiếu phụ thuộc\nTriệu chứng:\n\nERROR: Nothing PROVIDES 'missing-dependency'\n📋 Copy\nNguyên nhân: Recipe yêu cầu một phụ thuộc không tồn tại.\n\nGiải pháp:\n\n# Thêm recipe cho phụ thuộc bị thiếu\n# Hoặc sửa đổi DEPENDS trong recipe\nDEPENDS = \"existing-dependency other-dependency\"\n\n# Kiểm tra các gói có sẵn\nbitbake-layers show-recipes\n📋 Copy\n5.2. Lỗi xung đột phụ thuộc\nTriệu chứng:\n\nERROR: Multiple .bb files are due to be built which each provide virtual/dependency\n📋 Copy\nNguyên nhân: Nhiều recipe cung cấp cùng một phụ thuộc ảo.\n\nGiải pháp:\n\n# Chỉ định phiên bản ưu tiên trong local.conf\nPREFERRED_PROVIDER_virtual/dependency = \"specific-recipe\"\n\n# Kiểm tra các provider\nbitbake -e virtual/dependency | grep ^PREFERRED_PROVIDER\n📋 Copy\n5.3. Lỗi phiên bản không tương thích\nTriệu chứng:\n\nERROR: No compatible version found for package (wanted version X, available versions Y, Z)\n📋 Copy\nNguyên nhân: Phiên bản yêu cầu không khớp với phiên bản có sẵn.\n\nGiải pháp:\n\n# Chỉ định phiên bản ưu tiên\nPREFERRED_VERSION_package = \"X.Y.Z\"\n\n# Kiểm tra các phiên bản có sẵn\nbitbake-layers show-recipes package\n📋 Copy\n6. Lỗi recipe và layer\n6.1. Lỗi cú pháp recipe\nTriệu chứng:\n\nERROR: ParseError at /path/to/recipe.bb:10: Could not parse\n📋 Copy\nNguyên nhân: Lỗi cú pháp trong file recipe.\n\nGiải pháp:\n\n# Kiểm tra cú pháp với bitbake-diffsigs\nbitbake-diffsigs recipe-name\n\n# Sửa lỗi cú pháp\n# Thường là dấu ngoặc, dấu nháy hoặc dấu phẩy bị thiếu\n📋 Copy\n6.2. Lỗi LICENSE_CHECKSUM\nTriệu chứng:\n\nERROR: Recipe uses a deprecated license file md5sum\n📋 Copy\nNguyên nhân: Checksum của file LICENSE không chính xác.\n\nGiải pháp:\n\n# Cập nhật checksum\nLIC_FILES_CHKSUM = \"file://LICENSE;md5=new-md5-checksum\"\n\n# Tính toán md5sum mới\nmd5sum path/to/LICENSE\n📋 Copy\n6.3. Lỗi RDEPENDS\nTriệu chứng:\n\nERROR: Recipe runtime dependency 'package' not found in any recipe\n📋 Copy\nNguyên nhân: Runtime dependency không tồn tại.\n\nGiải pháp:\n\n# Kiểm tra tên gói chính xác\nbitbake-layers show-recipes | grep package\n\n# Sửa RDEPENDS\nRDEPENDS_${PN} = \"correct-package-name\"\n📋 Copy\n7. Lỗi khi tạo image\n7.1. Lỗi thiếu bộ nhớ\nTriệu chứng:\n\nERROR: No space left on rootfs\n📋 Copy\nNguyên nhân: Kích thước rootfs quá nhỏ cho các gói được cài đặt.\n\nGiải pháp:\n\n# Tăng kích thước rootfs trong local.conf\nIMAGE_ROOTFS_SIZE = \"8192\"  # Kích thước tính bằng KB\n\n# Hoặc loại bỏ một số gói\nIMAGE_INSTALL_remove = \"large-package\"\n📋 Copy\n7.2. Lỗi xung đột gói\nTriệu chứng:\n\nERROR: Package X conflicts with package Y\n📋 Copy\nNguyên nhân: Hai gói không thể cài đặt cùng nhau.\n\nGiải pháp:\n\n# Loại bỏ một trong các gói xung đột\nIMAGE_INSTALL_remove = \"conflicting-package\"\n\n# Hoặc chỉ định phiên bản không xung đột\nPREFERRED_VERSION_package = \"non-conflicting-version\"\n📋 Copy\n7.3. Lỗi thiếu gói\nTriệu chứng:\n\nERROR: Required package X not found in any package feed\n📋 Copy\nNguyên nhân: Gói yêu cầu không có sẵn.\n\nGiải pháp:\n\n# Thêm recipe cho gói bị thiếu\n# Hoặc thêm layer chứa gói\nbitbake-layers add-layer /path/to/layer-with-package\n\n# Kiểm tra tên gói chính xác\nbitbake-layers show-recipes | grep package-name\n📋 Copy\n8. Lỗi SDK\n8.1. Lỗi xây dựng SDK\nTriệu chứng:\n\nERROR: Function failed: populate_sdk\n📋 Copy\nNguyên nhân: Lỗi khi tạo SDK.\n\nGiải pháp:\n\n# Kiểm tra log chi tiết\nless tmp/work/*/temp/log.do_populate_sdk\n\n# Thêm các gói cần thiết vào SDK\nTOOLCHAIN_HOST_TASK += \"nativesdk-package\"\nTOOLCHAIN_TARGET_TASK += \"target-package\"\n📋 Copy\n8.2. Lỗi cài đặt SDK\nTriệu chứng:\n\nError: Unable to create directory /opt/poky/...\n📋 Copy\nNguyên nhân: Không có quyền ghi vào thư mục cài đặt.\n\nGiải pháp:\n\n# Chạy script cài đặt với sudo\nsudo ./poky-glibc-x86_64-core-image-minimal-toolchain-*.sh\n\n# Hoặc chỉ định thư mục cài đặt khác\n./poky-glibc-x86_64-core-image-minimal-toolchain-*.sh -d /path/with/write/permission\n📋 Copy\n8.3. Lỗi sử dụng SDK\nTriệu chứng:\n\nError: SDK environment script not found\n📋 Copy\nNguyên nhân: Script môi trường SDK không được tìm thấy hoặc không được chạy.\n\nGiải pháp:\n\n# Source script môi trường\nsource /opt/poky/*/environment-setup-*\n\n# Kiểm tra biến môi trường\necho $CC\n📋 Copy\n9. Các công cụ gỡ lỗi\n9.1. Kiểm tra log build\n# Xem log của task cụ thể\nbitbake -e recipe | grep ^T=\nless tmp/work/*/recipe/*/temp/log.do_task\n\n# Bật chế độ log chi tiết\nbitbake recipe -v\n\n# Xem log của task gần nhất thất bại\nbitbake recipe -c task -f -v\n📋 Copy\n9.2. Kiểm tra biến môi trường\n# Xem tất cả các biến của recipe\nbitbake -e recipe > recipe-env.txt\n\n# Tìm biến cụ thể\nbitbake -e recipe | grep ^VARIABLE=\n\n# Kiểm tra giá trị biến trong recipe\nbitbake -e recipe | grep ^S=\n📋 Copy\n9.3. Chạy task thủ công\n# Chạy lại task cụ thể\nbitbake recipe -c task -f\n\n# Chạy task với shell tương tác\nbitbake recipe -c devshell\n\n# Xóa trạng thái task và chạy lại\nbitbake recipe -c cleansstate\nbitbake recipe\n📋 Copy\n9.4. Kiểm tra phụ thuộc\n# Xem cây phụ thuộc\nbitbake -g recipe\ndot -Tpng -o deps.png task-depends.dot\n\n# Kiểm tra các gói cung cấp phụ thuộc\nbitbake -s | grep dependency\n\n# Xem các phụ thuộc của recipe\nbitbake -e recipe | grep ^DEPENDS=\n📋 Copy\n10. Kết luận\nYocto Project là một hệ thống phức tạp với nhiều thành phần tương tác, do đó việc gặp lỗi là điều không thể tránh khỏi trong quá trình phát triển. Tuy nhiên, với hiểu biết về các loại lỗi phổ biến và cách khắc phục, bạn có thể giải quyết chúng một cách hiệu quả.\n\nMột số lời khuyên chung khi gỡ lỗi trong Yocto:\n\nĐọc log cẩn thận: Hầu hết các lỗi đều có thông tin chi tiết trong log. Tập trung vào dòng cuối cùng của lỗi và theo dõi ngược lại để tìm nguyên nhân.\nTìm kiếm trong cộng đồng: Nhiều lỗi đã được báo cáo và giải quyết trong cộng đồng Yocto. Tìm kiếm trên Yocto Project mailing list, Stack Overflow hoặc GitHub issues.\nPhân chia vấn đề: Nếu bạn gặp nhiều lỗi cùng lúc, hãy giải quyết từng lỗi một. Bắt đầu với lỗi đầu tiên xuất hiện trong log.\nSử dụng các công cụ gỡ lỗi: Yocto cung cấp nhiều công cụ như bitbake -e, devshell và bitbake-layers để giúp bạn hiểu và gỡ lỗi.\nGiữ hệ thống sạch: Thường xuyên dọn dẹp các build cũ bằng cách sử dụng bitbake -c cleansstate để tránh các lỗi do trạng thái cũ.\nVới kiến thức về các lỗi phổ biến và cách khắc phục được trình bày trong bài viết này, bạn sẽ tự tin hơn khi phát triển với Yocto Project và có thể giải quyết các vấn đề một cách hiệu quả."}, {"id": "content/2-c-c-thu-t-ng-quan-tr-ng-trong-yocto.md", "title": "Các thuật ngữ cơ bản trong Yocto (Raspberry Pi 4)", "body": "# Các thuật ngữ cơ bản trong Yocto (Raspberry Pi 4)\n\nBài viết này đặc biệt phù hợp với những bạn mới bắt đầu tiếp cận Yocto và muốn nắm rõ các thuật ngữ thường được sử dụng, với ví dụ áp dụng cho **Raspberry Pi 4 (64-bit)**.\n\n---\n\n## 1. Image\nImage là một recipe định nghĩa những thành phần sẽ có trong root file system (RFS). Yocto cung cấp một số image mặc định trong Poky, chẳng hạn như `core-image-minimal`, đây là một image tối thiểu để hệ thống có thể khởi động.\n\nVí dụ: `core-image-minimal.bb`  \n\n```bitbake\nSUMMARY = \"A small image just capable of allowing a device to boot.\"\nIMAGE_INSTALL = \"packagegroup-core-boot ${CORE_IMAGE_EXTRA_INSTALL}\"\nIMAGE_LINGUAS = \" \"\nLICENSE = \"MIT\"\ninherit core-image\nIMAGE_ROOTFS_SIZE ?= \"8192\"\nIMAGE_ROOTFS_EXTRA_SPACE_append = \"${@bb.utils.contains(\"DISTRO_FEATURES\", \"systemd\", \" + 4096\", \"\" ,d)}\"\n```\n\n- **IMAGE_INSTALL**: Các gói cài vào RFS.  \n- **CORE_IMAGE_EXTRA_INSTALL**: Thêm gói tùy biến.  \n- **IMAGE_ROOTFS_SIZE**: Kích thước rootfs.  \n- **inherit core-image**: Kế thừa class định nghĩa image cơ bản.  \n\n---\n\n## 2. Machine file\nMachine mô tả phần cứng cụ thể để build image. Với Raspberry Pi 4, file cấu hình nằm trong `meta-raspberrypi/conf/machine/raspberrypi4-64.conf`.\n\nVí dụ rút gọn:  \n\n```conf\n#@TYPE: Machine\n#@NAME: Raspberry Pi 4 Model B\n#@DESCRIPTION: Machine configuration for Raspberry Pi 4 64-bit\n\nPREFERRED_PROVIDER_virtual/kernel ?= \"linux-raspberrypi\"\nUBOOT_MACHINE = \"rpi_4_defconfig\"\nKERNEL_IMAGETYPE = \"Image\"\n\nSERIAL_CONSOLES ?= \"115200;ttyAMA0\"\n\nMACHINE_FEATURES += \"wifi bluetooth vc4graphics\"\n```\n\n- **UBOOT_MACHINE**: chỉ định cấu hình U-Boot cho Pi 4.  \n- **KERNEL_IMAGETYPE**: dùng `Image` (ARM64) thay vì `bzImage`.  \n- **SERIAL_CONSOLES**: UART mặc định qua `ttyAMA0`.  \n- **MACHINE_FEATURES**: có thêm WiFi, Bluetooth, GPU VideoCore IV.  \n\n---\n\n## 3. Distro\nDistro là một bản phân phối hoàn chỉnh. Mặc định Yocto dùng `poky`, bạn có thể kiểm tra trong `conf/local.conf`:  \n\n```conf\nDISTRO ?= \"poky\"\n```\n\nFile cấu hình distro `poky.conf` định nghĩa:  \n\n- **DISTRO**: tên bản phân phối.  \n- **DISTRO_FEATURES**: các tính năng bật sẵn (như opengl, wayland, vulkan).  \n- **PREFERRED_VERSION_linux-yocto**: kernel mặc định, có thể override bằng kernel của Pi (`linux-raspberrypi`).  \n\n---\n\n## 4. Local.conf\n`local.conf` nằm trong `build/conf/` dùng để tùy chỉnh cho máy build:  \n\n- **MACHINE**:  \n  ```conf\n  MACHINE ?= \"raspberrypi4-64\"\n  ```\n- **IMAGE_FSTYPES**: định dạng image, ví dụ `.wic.bz2`.  \n- **BB_NUMBER_THREADS** và **PARALLEL_MAKE**: điều chỉnh luồng CPU để tăng tốc build.  \n- **TMPDIR**: thư mục chứa output build.  \n\n---\n\n## 5. Kết luận\nTrong bài viết này, chúng ta đã tìm hiểu các thuật ngữ cơ bản trong Yocto, áp dụng cho **Raspberry Pi 4**. Việc hiểu rõ Image, Machine, Distro và Local.conf sẽ giúp bạn dễ dàng tùy chỉnh và xây dựng hệ điều hành nhúng theo nhu cầu.  \n\n---\n"}, {"id": "content/3-ch-y-gi-l-p-image-b-ng-qemu.md", "title": "Xây dựng Image cho Raspberry Pi 4 với Yocto Project", "body": "# Xây dựng Image cho Raspberry Pi 4 với Yocto Project\n\n## 1. Yêu cầu phần cứng và phần mềm\n\n### 1.1. Yêu cầu phần cứng\nĐể quá trình build mượt mà, nên chuẩn bị:\n- **CPU**: Tối thiểu 4 nhân (quad-core) hoặc cao hơn\n- **RAM**: Tối thiểu 8GB (khuyến nghị 16GB+)\n- **Ổ đĩa**: Trống tối thiểu 50GB (khuyến nghị 100GB+). **SSD** sẽ nhanh hơn HDD\n- **Thiết bị**: Raspberry Pi 4 (1/2/4/8GB), thẻ **microSD ≥ 16GB**, nguồn tốt, cáp HDMI/USB-serial (tuỳ nhu cầu)\n\n### 1.2. Yêu cầu phần mềm\n- **Hệ điều hành host**: Ubuntu 20.04 LTS trở lên hoặc Debian 10+. (Fedora/CentOS dùng được nhưng có thể cần cấu hình thêm)\n\n### 1.3. Cấu hình tham khảo\n- Hệ điều hành: Ubuntu 22.04  \n- RAM: 8GB  \n- Ổ cứng: 100GB SSD  \n- CPU: 4 nhân, 2 luồng, 3.2GHz  \n\n---\n\n## 2. Chuẩn bị môi trường\n\n### 2.1. Cài đặt các công cụ cần thiết\n\n**Ubuntu / Debian**\n```bash\nsudo apt-get update\nsudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib \\\n  build-essential chrpath socat cpio python3 python3-pip python3-pexpect \\\n  xz-utils debianutils iputils-ping libsdl1.2-dev xterm vim zstd liblz4-tool\nFedora\n\nbash\nCopy\nEdit\nsudo dnf install gawk make wget tar bzip2 gzip python3 unzip perl patch \\\n  diffutils diffstat git cpp gcc gcc-c++ glibc-devel texinfo chrpath \\\n  ccache perl-Data-Dumper perl-Text-ParseWords perl-Thread-Queue perl-bignum socat \\\n  python3-pexpect findutils which file cpio python3-pip xz SDL-devel xterm zstd lz4\n3. Tải mã nguồn Yocto Project\n3.1. Chuẩn bị thư mục & clone\nbash\nCopy\nEdit\nmkdir -p ~/yocto\ncd ~/yocto\n\n# Poky (chọn nhánh cho phù hợp, ví dụ dunfell để đồng bộ với hướng dẫn)\ngit clone -b dunfell git://git.yoctoproject.org/poky\ncd poky\n\n# Layer cho Raspberry Pi + OE\ngit clone -b dunfell git://git.yoctoproject.org/meta-raspberrypi\ngit clone -b dunfell git://git.openembedded.org/meta-openembedded\n3.2. Cấu trúc chính trong Poky (nhắc lại nhanh)\nbitbake/ – công cụ BitBake\n\nmeta/ – layer lõi (OE-Core)\n\nmeta-poky/ – distro tham chiếu Poky\n\nmeta-yocto-bsp/ – BSP mẫu\n\noe-init-build-env – script thiết lập môi trường build\n\n4. Xây dựng image cho Raspberry Pi 4\nRaspberry Pi 4 là ARM64, dùng MACHINE: raspberrypi4-64.\n\n4.1. Chuyển nhánh (nếu cần)\nbash\nCopy\nEdit\ncd ~/yocto/poky\ngit checkout dunfell\n4.2. Khởi tạo môi trường build\nbash\nCopy\nEdit\nsource oe-init-build-env\nSau lệnh này sẽ có thư mục build/ chứa cấu hình.\n\n4.3. Tùy chỉnh file cấu hình\n4.3.1. conf/local.conf\nMở poky/build/conf/local.conf và cập nhật:\n\nconf\nCopy\nEdit\n# Tiết kiệm dung lượng (xóa work sau build xong)\nINHERIT += \"rm_work\"\n\n# Định dạng gói (mặc định là RPM, có thể giữ nguyên)\nPACKAGE_CLASSES ?= \"package_rpm\"\n\n# Quan trọng: target board\nMACHINE ?= \"raspberrypi4-64\"\n\n# Một số tiện ích khuyến nghị (tuỳ chọn)\nEXTRA_IMAGE_FEATURES ?= \"debug-tweaks\"\n\n# (Tuỳ chọn) Thêm Wi-Fi/Bluetooth tools & firmware\nIMAGE_INSTALL:append = \" linux-firmware-brcm43455 pi-bluetooth iw wpa-supplicant bluez5\"\n4.3.2. conf/bblayers.conf\nThêm meta-raspberrypi và meta-openembedded/meta-oe:\n\nconf\nCopy\nEdit\nBBLAYERS ?= \" \\\n  /home/<user>/yocto/poky/meta \\\n  /home/<user>/yocto/poky/meta-poky \\\n  /home/<user>/yocto/poky/meta-yocto-bsp \\\n  /home/<user>/yocto/poky/meta-raspberrypi \\\n  /home/<user>/yocto/poky/meta-openembedded/meta-oe \\\n\"\nThay <user> bằng tên người dùng/đường dẫn thực tế.\n\n4.4. Tiến hành build\nBạn có thể build image tối thiểu hoặc có giao diện:\n\nbash\nCopy\nEdit\n# Image console tối thiểu\nbitbake core-image-minimal\n\n# (Tuỳ chọn) Image có giao diện Sato\n# bitbake core-image-sato\n4.5. Vị trí image đầu ra\nSau khi build xong, image nằm tại:\n\nswift\nCopy\nEdit\nbuild/tmp/deploy/images/raspberrypi4-64/\nThường có các định dạng như .wic.bz2, .rpi-sdimg, v.v.\n\n4.6. Ghi image vào thẻ microSD\nXác định thiết bị thẻ nhớ:\n\nbash\nCopy\nEdit\nlsblk\nGiải nén & ghi image (ví dụ dùng .wic.bz2):\n\nbash\nCopy\nEdit\ncd ~/yocto/poky/build/tmp/deploy/images/raspberrypi4-64/\n\n# Chọn đúng file .wic.bz2 sinh ra\ncp core-image-minimal-raspberrypi4-64-*.wic.bz2 ./temp.wic.bz2\nbzip2 -d temp.wic.bz2\n\n# CẢNH BÁO: thay /dev/sdX bằng thiết bị thẻ nhớ chính xác!\nsudo dd if=temp.wic of=/dev/sdX bs=4M status=progress conv=fsync\nsync\n(Tuỳ chọn) Nếu có .bmap, dùng bmaptool sẽ nhanh hơn:\n\nbash\nCopy\nEdit\nsudo apt-get install bmap-tools\nsudo bmaptool copy core-image-minimal-raspberrypi4-64-*.wic.bz2 /dev/sdX\n4.7. Khởi động Raspberry Pi 4\nCắm thẻ microSD vào Pi 4, cấp nguồn.\n\nKết nối HDMI để theo dõi boot (nếu image đồ hoạ) hoặc UART/SSH (nếu image console).\n\nVới debug-tweaks, tài khoản root thường không mật khẩu khi truy cập terminal trực tiếp.\n\nCấu hình Wi-Fi (nếu cần):\n\nbash\nCopy\nEdit\n# ví dụ đơn giản với wpa_cli / wpa_supplicant\n# hoặc tạo /etc/wpa_supplicant/wpa_supplicant.conf\n5. Kết luận\nBạn đã:\n\nChuyển từ môi trường QEMU sang Raspberry Pi 4 (raspberrypi4-64)\n\nThêm meta-raspberrypi, cấu hình local.conf & bblayers.conf phù hợp\n\nBuild image và flash vào thẻ microSD để chạy trên phần cứng thực\n\nYocto cho phép tuỳ biến rất cao. Từ đây, bạn có thể thêm package, firmware, UI (Sato/Wayland), hoặc tích hợp CI/CD theo nhu cầu."}, {"id": "content/4-t-o-layer-n-gi-n-v-th-m-ch-ng-tr-nh-helloworld.md", "title": "Xây dựng Image cho Raspberry Pi 4 với Yocto Project", "body": "# Xây dựng Image cho Raspberry Pi 4 với Yocto Project\n\n## 1. Yêu cầu phần cứng và phần mềm\n\n### 1.1. Yêu cầu phần cứng\nĐể quá trình build mượt mà, nên chuẩn bị:\n- **CPU**: Tối thiểu 4 nhân (quad-core) hoặc cao hơn\n- **RAM**: Tối thiểu 8GB (khuyến nghị 16GB+)\n- **Ổ đĩa**: Trống tối thiểu 50GB (khuyến nghị 100GB+). **SSD** sẽ nhanh hơn HDD\n- **Thiết bị**: Raspberry Pi 4 (1/2/4/8GB), thẻ **microSD ≥ 16GB**, nguồn tốt, cáp HDMI/USB-serial (tuỳ nhu cầu)\n\n### 1.2. Yêu cầu phần mềm\n- **Hệ điều hành host**: Ubuntu 20.04 LTS trở lên hoặc Debian 10+. (Fedora/CentOS dùng được nhưng có thể cần cấu hình thêm)\n\n### 1.3. Cấu hình tham khảo\n- Hệ điều hành: Ubuntu 22.04  \n- RAM: 8GB  \n- Ổ cứng: 100GB SSD  \n- CPU: 4 nhân, 2 luồng, 3.2GHz  \n\n---\n\n## 2. Chuẩn bị môi trường\n\n### 2.1. Cài đặt các công cụ cần thiết\n\n**Ubuntu / Debian**\n```bash\nsudo apt-get update\nsudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib   build-essential chrpath socat cpio python3 python3-pip python3-pexpect   xz-utils debianutils iputils-ping libsdl1.2-dev xterm vim zstd liblz4-tool\n```\n\n**Fedora**\n```bash\nsudo dnf install gawk make wget tar bzip2 gzip python3 unzip perl patch   diffutils diffstat git cpp gcc gcc-c++ glibc-devel texinfo chrpath   ccache perl-Data-Dumper perl-Text-ParseWords perl-Thread-Queue perl-bignum socat   python3-pexpect findutils which file cpio python3-pip xz SDL-devel xterm zstd lz4\n```\n\n---\n\n## 3. Tải mã nguồn Yocto Project\n\n### 3.1. Chuẩn bị thư mục & clone\n```bash\nmkdir -p ~/yocto\ncd ~/yocto\n\n# Poky (chọn nhánh cho phù hợp, ví dụ dunfell để đồng bộ với hướng dẫn)\ngit clone -b dunfell git://git.yoctoproject.org/poky\ncd poky\n\n# Layer cho Raspberry Pi + OE\ngit clone -b dunfell git://git.yoctoproject.org/meta-raspberrypi\ngit clone -b dunfell git://git.openembedded.org/meta-openembedded\n```\n\n### 3.2. Cấu trúc chính trong Poky (nhắc lại nhanh)\n- **bitbake/** – công cụ BitBake\n- **meta/** – layer lõi (OE-Core)\n- **meta-poky/** – distro tham chiếu Poky\n- **meta-yocto-bsp/** – BSP mẫu\n- **oe-init-build-env** – script thiết lập môi trường build\n\n---\n\n## 4. Xây dựng image cho Raspberry Pi 4\n\n> Raspberry Pi 4 là **ARM64**, dùng MACHINE: `raspberrypi4-64`.\n\n### 4.1. Chuyển nhánh (nếu cần)\n```bash\ncd ~/yocto/poky\ngit checkout dunfell\n```\n\n### 4.2. Khởi tạo môi trường build\n```bash\nsource oe-init-build-env\n```\nSau lệnh này sẽ có thư mục `build/` chứa cấu hình.\n\n### 4.3. Tùy chỉnh file cấu hình\n\n#### 4.3.1. `conf/local.conf`\nMở `poky/build/conf/local.conf` và cập nhật:\n```conf\n# Tiết kiệm dung lượng (xóa work sau build xong)\nINHERIT += \"rm_work\"\n\n# Định dạng gói (mặc định là RPM, có thể giữ nguyên)\nPACKAGE_CLASSES ?= \"package_rpm\"\n\n# Quan trọng: target board\nMACHINE ?= \"raspberrypi4-64\"\n\n# Một số tiện ích khuyến nghị (tuỳ chọn)\nEXTRA_IMAGE_FEATURES ?= \"debug-tweaks\"\n\n# (Tuỳ chọn) Thêm Wi-Fi/Bluetooth tools & firmware\nIMAGE_INSTALL:append = \" linux-firmware-brcm43455 pi-bluetooth iw wpa-supplicant bluez5\"\n```\n\n#### 4.3.2. `conf/bblayers.conf`\nThêm `meta-raspberrypi` và `meta-openembedded/meta-oe`:\n```conf\nBBLAYERS ?= \"   /home/<user>/yocto/poky/meta   /home/<user>/yocto/poky/meta-poky   /home/<user>/yocto/poky/meta-yocto-bsp   /home/<user>/yocto/poky/meta-raspberrypi   /home/<user>/yocto/poky/meta-openembedded/meta-oe \"\n```\n> Thay `<user>` bằng tên người dùng/đường dẫn thực tế.\n\n### 4.4. Tiến hành build\nBạn có thể build image tối thiểu hoặc có giao diện:\n```bash\n# Image console tối thiểu\nbitbake core-image-minimal\n\n# (Tuỳ chọn) Image có giao diện Sato\n# bitbake core-image-sato\n```\n\n### 4.5. Vị trí image đầu ra\nSau khi build xong, image nằm tại:\n```\nbuild/tmp/deploy/images/raspberrypi4-64/\n```\nThường có các định dạng như `.wic.bz2`, `.rpi-sdimg`, v.v.\n\n### 4.6. Ghi image vào thẻ microSD\n\n**Xác định thiết bị thẻ nhớ**:\n```bash\nlsblk\n```\n\n**Giải nén & ghi image** (ví dụ dùng `.wic.bz2`):\n```bash\ncd ~/yocto/poky/build/tmp/deploy/images/raspberrypi4-64/\n\n# Chọn đúng file .wic.bz2 sinh ra\ncp core-image-minimal-raspberrypi4-64-*.wic.bz2 ./temp.wic.bz2\nbzip2 -d temp.wic.bz2\n\n# CẢNH BÁO: thay /dev/sdX bằng thiết bị thẻ nhớ chính xác!\nsudo dd if=temp.wic of=/dev/sdX bs=4M status=progress conv=fsync\nsync\n```\n> (Tuỳ chọn) Nếu có `.bmap`, dùng `bmaptool` sẽ nhanh hơn:\n> ```bash\n> sudo apt-get install bmap-tools\n> sudo bmaptool copy core-image-minimal-raspberrypi4-64-*.wic.bz2 /dev/sdX\n> ```\n\n### 4.7. Khởi động Raspberry Pi 4\n- Cắm thẻ microSD vào Pi 4, cấp nguồn.  \n- Kết nối **HDMI** để theo dõi boot (nếu image đồ hoạ) hoặc **UART**/SSH (nếu image console).  \n- Với `debug-tweaks`, tài khoản `root` thường **không mật khẩu** khi truy cập terminal trực tiếp.  \n- Cấu hình Wi-Fi (nếu cần):\n  ```bash\n  # ví dụ đơn giản với wpa_cli / wpa_supplicant\n  # hoặc tạo /etc/wpa_supplicant/wpa_supplicant.conf\n  ```\n\n## Phụ lục — Cấu hình Wi-Fi (wpa_supplicant.conf)\n\n> Yêu cầu: trong `local.conf` đã có `wpa-supplicant` (ví dụ `IMAGE_INSTALL:append = \" wpa-supplicant\"` hoặc theo mẫu ở trên).\n\n**Tạo file trên target**: `/etc/wpa_supplicant/wpa_supplicant.conf`\n```conf\nctrl_interface=/var/run/wpa_supplicant\nupdate_config=1\ncountry=VN\n\nnetwork={\n    ssid=\"Ten_WiFi_cua_ban\"\n    psk=\"Mat_khau_WiFi\"\n    key_mgmt=WPA-PSK\n    priority=10\n}\n---\n\n## 5. Kết luận\nBạn đã:\n- Chuyển từ môi trường QEMU sang **Raspberry Pi 4 (raspberrypi4-64)**  \n- Thêm `meta-raspberrypi`, cấu hình `local.conf` & `bblayers.conf` phù hợp  \n- Build image và flash vào thẻ microSD để chạy trên phần cứng thực\n\nYocto cho phép tuỳ biến rất cao. Từ đây, bạn có thể thêm package, firmware, UI (Sato/Wayland), hoặc tích hợp CI/CD theo nhu cầu.\n"}, {"id": "content/5-t-m-hi-u-v-devtool-trong-yocto.md", "title": "Devtool trong Yocto: Tạo, chỉnh sửa và kiểm thử recipe nhanh", "body": "# Devtool trong Yocto: Tạo, chỉnh sửa và kiểm thử recipe nhanh\n\nTrong các bài viết trước, chúng ta đã cùng tìm hiểu cách tạo một **layer** đơn giản trên Yocto và chạy giả lập trên **QEMU**. Tiếp nối chuỗi bài viết về **Yocto Project**, hôm nay chúng ta sẽ khám phá **Devtool** – một công cụ hỗ trợ mạnh mẽ giúp các nhà phát triển dễ dàng **tạo**, **chỉnh sửa** và **kiểm thử** các recipe trong Yocto.\n\nDevtool được thiết kế để **đơn giản hóa quy trình** làm việc với Yocto. Thay vì thao tác thủ công, Devtool cho phép nhanh chóng tạo, sửa và cập nhật recipe; đồng thời build & kiểm thử gói phần mềm trước khi tích hợp vào image cuối cùng.\n\n---\n\n## 1. Tổng quan về Devtool\n\nDevtool dùng để:\n\n- Tạo mới, chỉnh sửa và cập nhật **recipe**  \n- **Build** và kiểm thử **package**  \n- Tích hợp thay đổi vào **image** nhanh chóng\n\nThiết lập môi trường trước khi dùng:\n\n```bash\n~/yocto/poky$ source oe-init-build-env\n```\n\nXem các subcommand có sẵn:\n\n```bash\n~/yocto/poky/build$ devtool -h\n```\n\nMột số subcommand phổ biến:\n- `add` – Tạo recipe mới\n- `modify` – Chỉnh sửa source/recipe hiện có (đưa về workspace)\n- `build` – Build recipe hoặc image\n- `deploy-target` – Triển khai nhanh gói lên target qua SSH\n- `finish` – Hoàn tất, đưa recipe từ workspace vào layer\n- `reset` – Hủy thay đổi trong workspace\n- `upgrade` – Nâng cấp recipe\n- `update-recipe` – Cập nhật recipe theo thay đổi trong source\n\n---\n\n## 2. Các lệnh phổ biến của Devtool\n\n### 2.1. `devtool add`\n\nTạo recipe mới từ source có sẵn (local hoặc remote). Sau khi chạy, Devtool tạo **workspace** chứa source và recipe.\n\n**Ví dụ**: tạo recipe từ GitHub\n\n```bash\n~/yocto/poky/build$ devtool add hello-devtool https://github.com/thanhdeptrai097/Yocto-For-Dummies.git --srcbranch custom-devtool\n```\n\nCấu trúc workspace rút gọn:\n\n```\nworkspace/\n├── appends     # Lưu các thay đổi khi modify/upgrade\n├── conf        # Lưu các file cấu hình\n├── README\n├── recipes     # Lưu các recipe mới được tạo\n└── sources     # Lưu source code\n```\n\nĐọc source vừa fetch:\n\n```bash\n~/yocto/poky/build$ cat workspace/sources/hello-devtool/hello-devtool.c\n```\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    printf(\"thanhdeptrai: hello devtool!\\n\");\n    return 0;\n}\n```\n\nRecipe tự sinh `hello-devtool_git.bb` (rút gọn):\n\n```bitbake\n# Recipe created by recipetool\n# (cần chỉnh sửa LICENSE/LIC_FILES_CHKSUM cho phù hợp)\nLICENSE = \"CLOSED\"\nLIC_FILES_CHKSUM = \"\"\n\nSRC_URI = \"git://github.com/thanhdeptrai097/Yocto-For-Dummies.git;protocol=https;branch=custom-devtool\"\n\n# Modify these as desired\nPV = \"1.0+git${SRCPV}\"\nSRCREV = \"9684263baeb96af50c937da46a63065c42703963\"\n\nS = \"${WORKDIR}/git\"\n\n# NOTE: no Makefile found, unable to determine what needs to be done\ndo_configure () { : }\ndo_compile () { : }\ndo_install () { : }\n```\n\n---\n\n### 2.2. `devtool build`\n\nBuild recipe để kiểm thử nhanh package.\n\nChỉnh `hello-devtool_git.bb` tối thiểu để biên dịch & cài:\n\n```bitbake\nLICENSE = \"CLOSED\"\nLIC_FILES_CHKSUM = \"\"\n\nSRC_URI = \"git://github.com/thanhdeptrai097/Yocto-For-Dummies.git;protocol=https;branch=custom-devtool\"\n\nPV = \"1.0+git${SRCPV}\"\nSRCREV = \"9684263baeb96af50c937da46a63065c42703963\"\n\nS = \"${WORKDIR}/git\"\n\ndo_compile () {\n    ${CC} ${S}/hello-devtool.c ${LDFLAGS} -o ${S}/hello-devtool\n}\n\ndo_install () {\n    install -d ${D}${bindir}\n    install -m 0755 ${S}/hello-devtool ${D}${bindir}\n}\n```\n\nBuild thử:\n\n```bash\n~/yocto/poky/build$ devtool build hello-devtool\n```\n\nVí dụ kết quả thành công:\n\n```\nSstate summary: Wanted 0 Found 0 Missed 0 Current 124 (0% match, 100% complete)\nNOTE: Executing Tasks\nNOTE: hello-devtool: compiling from external source tree ...\nNOTE: Tasks Summary: Attempted 531 tasks ... all succeeded.\n```\n\nThêm vào image để test trên target:\n\n```conf\n# build/conf/local.conf\nIMAGE_INSTALL_append = \" hello-devtool\"\n```\n\nBuild & chạy QEMU:\n\n```bash\nbitbake core-image-minimal\nrunqemu qemux86-64 nographic\n```\n\nKiểm tra trên target:\n\n```bash\nroot@arm:~# /usr/bin/hello-devtool\nthanhdeptrai: hello devtool!\n```\n\n---\n\n### 2.3. `devtool deploy-target`\n\nTriển khai nhanh recipe đã build lên target qua **SSH** (không cần rebuild image).\n\n**Chuẩn bị**: image có SSH server (dropbear/openssh). Ví dụ:\n\n```conf\n# build/conf/local.conf\nIMAGE_INSTALL_append = \" openssh\"\n# hoặc\n# EXTRA_IMAGE_FEATURES += \"ssh-server-openssh\"\n```\n\nKhởi chạy image rồi deploy:\n\n```bash\n# QEMU ví dụ\nrunqemu qemux86-64 nographic\n\n# Từ host (IP ví dụ 192.168.7.2)\n~/yocto/poky/build$ devtool deploy-target hello-devtool root@192.168.7.2\n```\n\nChạy thử trên target:\n\n```bash\nroot@arm:~# /usr/bin/hello-devtool\nthanhdeptrai: hello devtool!\n```\n\n---\n\n### 2.4. `devtool finish`\n\nKhi đã ổn, chuyển recipe từ workspace vào một layer của bạn:\n\n```bash\n~/yocto/poky/build$ devtool finish -f hello-devtool ../meta-thanhdeptrai/recipes-apps/\n```\n\nTrước khi thêm:\n\n```\nmeta-thanhdeptrai/recipes-apps\n└── hello-world\n    ├── files\n    │   └── hello-world.c\n    └── hello-world.bb\n```\n\nSau khi thêm:\n\n```\nmeta-thanhdeptrai/recipes-apps\n├── hello-devtool\n│   └── hello-devtool_git.bb\n└── hello-world\n    ├── files\n    │   └── hello-world.c\n    └── hello-world.bb\n```\n\n---\n\n### 2.5. `devtool modify`\n\nĐưa source/recipe hiện có vào workspace để sửa:\n\n```bash\n~/yocto/poky/build$ devtool modify hello-devtool\n```\n\nSửa source, ví dụ:\n\n```c\nint main()\n{\n    printf(\"thanhdeptrai: hello devtool!\\n\");\n    printf(\"This line edit in devtool modify.\\n\");\n    return 0;\n}\n```\n\nBuild lại & kiểm thử như trên.\n\n---\n\n### 2.6. `devtool reset`\n\nHủy bỏ mọi thay đổi trong workspace cho recipe:\n\n```bash\ndevtool reset hello-devtool\n```\n\n---\n\n### 2.7. `devtool update-recipe`\n\nKhi source đã thay đổi (đã commit), cập nhật lại recipe.\n\nSửa code:\n\n```c\nint main()\n{\n    printf(\"thanhdeptrai: hello devtool!\\n\");\n    printf(\"This line edit in devtool modify.\\n\");\n    printf(\"This line is changed in devtool update-recipe\\n\");\n    return 0;\n}\n```\n\nCommit & cập nhật:\n\n```bash\n~/yocto/poky/build/workspace/sources/hello-devtool$ git add hello-devtool.c\n~/yocto/poky/build/workspace/sources/hello-devtool$ git commit -m \"Demo devtool update-recipe\"\n~/yocto/poky/build$ devtool update-recipe hello-devtool\n```\n\nKiểm tra recipe trong layer:\n\n```\nmeta-thanhdeptrai/recipes-apps/hello-devtool\n├── hello-devtool\n│   └── 0001-Demo-devtool-update-recipe.patch\n└── hello-devtool_git.bb\n```\n\n> File patch chứa chi tiết các thay đổi đã ghi nhận.\n\n---\n\n## 3. Kết luận\n\n**Devtool** là công cụ mạnh mẽ và linh hoạt giúp:\n- Tạo mới/chỉnh sửa recipe nhanh chóng\n- Build & test gói trước khi bake vào image\n- Deploy nhanh lên target qua SSH\n- Dễ dàng “finish” để đưa recipe vào layer\n\nTừ đây, bạn có thể kết hợp Devtool với **CI/CD**, chuyển sang phần cứng thực (vd. Raspberry Pi 4 với `MACHINE = \"raspberrypi4-64\"` + `meta-raspberrypi`), hoặc duy trì vòng lặp phát triển rất ngắn nhờ `devtool deploy-target`.\n"}, {"id": "content/6-package-dependencies-v-splitting-trong-yocto.md", "title": "Package Dependencies và Package Splitting trong Yocto", "body": "# Package Dependencies và Package Splitting trong Yocto\n\nTrong bài viết này, chúng ta sẽ cùng khám phá hai khái niệm quan trọng trong **Yocto**:  \n**Package Dependencies** (phụ thuộc của gói) và **Package Splitting** (phân chia gói).  \nĐây là các khái niệm cốt lõi giúp tối ưu hoá hiệu suất và tăng tính linh hoạt khi xây dựng hệ thống nhúng hoặc phân phối Linux.\n\nKhi làm việc với Yocto, việc quản lý phụ thuộc gói và chia gói đóng vai trò thiết yếu trong việc **giảm dung lượng**, **cải thiện hiệu quả**, và **nâng cao khả năng bảo trì** hệ thống.\n\n---\n\n## 1. Package Dependencies\n\n**Package Dependencies** là các yêu cầu cần thiết để một gói hoạt động bình thường. Nếu một gói cần thư viện hoặc các gói khác, Yocto sẽ đảm bảo các yêu cầu này được thiết lập trước (hoặc sau) khi build package. Có hai nhóm phụ thuộc chính:\n\n- **Build time dependencies**: Phụ thuộc cần trong **quá trình build** → dùng biến `DEPENDS`.\n- **Run time dependencies**: Phụ thuộc cần **khi chạy** → dùng biến `RDEPENDS_${PN}`.\n\n### 1.1. Build time dependencies\n\nTại thời điểm build, một số thư viện hoặc package khác là cần thiết để đảm bảo quá trình build diễn ra thành công. Trong Yocto, biến **`DEPENDS`** dùng để chỉ định các gói/thư viện cần có trong **sysroots** trước khi `do_compile()` chạy.\n\n#### 1.1.1. Thiết lập môi trường\n\n```bash\n~/yocto/poky$ source oe-init-build-env\n```\n\n#### 1.1.2. Tạo mã nguồn và recipe\n\nTạo thư mục chứa recipe **`demo-dependencies`** trong `meta-thanhdeptrai/recipes-apps`, sau đó thêm source & recipe theo cấu trúc:\n\n```bash\n~/yocto/poky/meta-thanhdeptrai/recipes-apps$ mkdir demo-dependencies\n~/yocto/poky/meta-thanhdeptrai/recipes-apps/demo-dependencies$ tree\n.\n├── files\n│   ├── depend_buildtime.c\n│   ├── depend_runtime.c\n│   ├── package_split.c\n│   └── Makefile\n└── demo-dependencies.bb\n```\n\n**`depend_buildtime.c`**\n\n```c\n#include <stdio.h>\n#include <curl/curl.h>\n\nint main(void)\n{\n    CURL *curl;\n    CURLcode res;\n\n    printf(\"thanhdeptrai\\n\");\n    curl = curl_easy_init();\n    if (curl) {\n        printf(\"Build dependency check: OK\\n\");\n        curl_easy_cleanup(curl);\n    }\n\n    return 0;\n}\n```\n\n**`depend_runtime.c`**\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void)\n{\n    printf(\"thanhdeptrai\\n\");\n    int status = system(\"bash -c 'echo This is executed by bash at runtime!'\");\n    if (status == -1) {\n        perror(\"Failed to run bash command\");\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n**`package_split.c`**\n\n```c\n#include <stdio.h>\n\nint main(void)\n{\n    printf(\"thanhdeptrai: package splitting!\\n\");\n    return 0;\n}\n```\n\n**`Makefile`**\n\n```makefile\nCC = gcc\nCFLAGS = -Wall\n\nall: depend_buildtime depend_runtime package_split\n\ndepend_buildtime: depend_buildtime.c\n\t$(CC) depend_buildtime.c $(CFLAGS) -lcurl -o depend_buildtime\n\ndepend_runtime: depend_runtime.c\n\t$(CC) depend_runtime.c $(CFLAGS) -o depend_runtime\n\npackage_split: package_split.c\n\t$(CC) package_split.c $(CFLAGS) -o package_split\n\nclean:\n\trm -rf depend_buildtime package_split depend_runtime\n```\n\n**`demo-dependencies.bb`**\n\n```bitbake\nDESCRIPTION = \"Demo program showcasing package dependencies and splitting\"\nLICENSE = \"MIT\"\nLIC_FILES_CHKSUM = \"file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4f302\"\n\nS = \"${WORKDIR}\"\nSRC_URI = \"file://depend_buildtime.c \\\n           file://depend_runtime.c \\\n           file://package_split.c \\\n           file://Makefile\"\n\n# DEPENDS = \"curl\"\n\nEXTRA_OEMAKE = \"CC='${CC}' CFLAGS='${CFLAGS} -Wl,--hash-style=gnu'\"\n\ndo_compile() {\n    oe_runmake\n}\n\ndo_install() {\n    install -d ${D}${bindir}\n    install -m 0755 depend_buildtime ${D}${bindir}/depend_buildtime\n    install -m 0755 depend_runtime ${D}${bindir}/depend_runtime\n    install -m 0755 package_split ${D}${bindir}/package_split\n}\n```\n\n#### 1.1.3. Build recipe\n\n```bash\n~/yocto/poky$ bitbake demo-dependencies\n```\n\n**Lỗi thường gặp** (thiếu thư viện curl):\n\n```\n| depend_buildtime.c:2:10: fatal error: curl/curl.h: No such file or directory\n|     2 | #include <curl/curl.h>\n|       |          ^~~~~~~~~~~~~\n```\n\n**Nguyên nhân**: `DEPENDS` chưa khai báo `curl`, nên sysroots không có headers/lib phục vụ build.  \n**Khắc phục**: Bỏ comment `DEPENDS = \"curl\"` trong `.bb`, rồi build lại.\n\nKhi build thành công sẽ thấy:\n\n```\nNOTE: Tasks Summary: Attempted 3353 tasks of which 3328 didn't need to be rerun and all succeeded.\n```\n\n#### 1.1.4. Thêm libcurl vào image (runtime)\n\n```conf\n# build/conf/local.conf\nIMAGE_INSTALL_append = \" libcurl\"\n```\n\n### 1.2. Run time dependencies\n\n**Run time dependencies** là các gói, thư viện hoặc công cụ cần để chương trình **chạy**. Khai báo bằng `RDEPENDS_${PN}`.\n\n**Ví dụ lỗi** với `depend_runtime` do gọi `bash` qua `system()` nhưng image **không có** gói `bash`:\n\n```\nsh: bash: not found\n```\n\n**Khắc phục** trong recipe:\n\n```bitbake\nRDEPENDS_${PN} = \"bash\"\n```\n\nVà trong image (nếu muốn có sẵn):\n\n```conf\nIMAGE_INSTALL_append = \" bash\"\n```\n\nBuild lại image:\n\n```bash\n~/yocto/poky$ bitbake core-image-minimal\n~/yocto/poky$ runqemu qemux86-64 nographic\n```\n\nChạy lại test:\n\n```\nroot@qemux86-64:~# depend_runtime\nthanhdeptrai\nThis is executed by bash at runtime!\n```\n\n---\n\n## 2. Package Splitting\n\nTrong nhiều trường hợp, **không cần** cài đặt toàn bộ nội dung của một package vào image. Để tối ưu dung lượng và cho phép quản lý linh hoạt, Yocto hỗ trợ **chia package** thành các **subpackages** dùng các biến `PACKAGES` và `FILES_*`.\n\n### 2.1. Recipe mẫu tách gói\n\n```bitbake\nDESCRIPTION = \"Demo program showcasing package dependencies and splitting\"\nLICENSE = \"MIT\"\nLIC_FILES_CHKSUM = \"file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4f302\"\n\nS = \"${WORKDIR}\"\nSRC_URI = \"file://depend_buildtime.c \\\n           file://depend_runtime.c \\\n           file://package_split.c \\\n           file://Makefile\"\n\nDEPENDS = \"curl\"\nRDEPENDS_${PN} = \"bash\"\nRDEPENDS_package-split = \"bash\"\n\nEXTRA_OEMAKE = \"CC='${CC}' CFLAGS='${CFLAGS} -Wl,--hash-style=gnu'\"\n\n# Khai báo các package con\nPACKAGES =+ \"demo-tools package-split\"\n\n# Gộp depend_buildtime và depend_runtime vào package demo-tools\nFILES_demo-tools = \"${bindir}/depend_buildtime \\\n                    ${bindir}/depend_runtime\"\n\n# Khai báo package riêng cho package_split\nFILES_package-split = \"${bindir}/package_split\"\n\ndo_compile() {\n    oe_runmake\n}\n\ndo_install() {\n    install -d ${D}${bindir}\n    install -m 0755 depend_buildtime ${D}${bindir}/depend_buildtime\n    install -m 0755 depend_runtime ${D}${bindir}/depend_runtime\n    install -m 0755 package_split ${D}${bindir}/package_split\n}\n```\n\n### 2.2. Giải thích\n\n- `PACKAGES =+ \"demo-tools package-split\"`: khai báo thêm **hai** subpackages.\n- `FILES_demo-tools`: gom **`depend_buildtime`** & **`depend_runtime`** vào cùng một subpackage **demo-tools**.\n- `FILES_package-split`: tách **`package_split`** thành gói riêng **package-split**.\n- `RDEPENDS_package-split = \"bash\"`: nếu subpackage cần phụ thuộc runtime riêng, có thể khai báo tại đây.\n- Khi build, BitBake sẽ sinh ra nhiều gói (ipk/deb/rpm) tương ứng với từng subpackage.\n\n### 2.3. Cài đặt có chọn lọc\n\nChỉ muốn cài **demo-tools** (không cài `package-split`) vào image:\n\n```conf\nIMAGE_INSTALL_append = \" demo-tools\"\n```\n\nBuild & chạy:\n\n```bash\nbitbake core-image-minimal\nrunqemu qemux86-64 nographic\n```\n\nKiểm thử:\n\n```\nroot@qemux86-64:~# depend_buildtime\nthanhdeptrai\nBuild dependency check: OK\n\nroot@qemux86-64:~# depend_runtime\nthanhdeptrai\nThis is executed by bash at runtime!\n\nroot@qemux86-64:~# package_split\n-sh: package_split: command not found\n```\n\n---\n\n## 3. Kết luận\n\n- **Package Dependencies** đảm bảo các gói/thư viện cần thiết có mặt đúng lúc (build-time qua `DEPENDS`, runtime qua `RDEPENDS_*`).  \n- **Package Splitting** cho phép chia nhỏ gói thành các **subpackage** để **tối ưu dung lượng** và **cài đặt linh hoạt**.  \n- Áp dụng đúng `DEPENDS`, `RDEPENDS_*`, `PACKAGES`, `FILES_*` giúp hệ thống **ổn định**, **nhẹ**, và **dễ bảo trì**.\n"}, {"id": "content/7-build-sdk-b-ng-yocto.md", "title": "Hướng dẫn Build & Sử dụng **SDK Yocto** cho **Raspberry Pi 4 (raspberrypi4-64)**", "body": "# Hướng dẫn Build & Sử dụng **SDK Yocto** cho **Raspberry Pi 4 (raspberrypi4-64)**\n\nTài liệu này chuyển thể từ bài viết SDK tổng quan và **được điu chỉnh cho Raspberry Pi 4 (ARM64)**.  \nBạn sẽ biết cách **tạo SDK chuẩn / eSDK**, **cài đặt**, **thiết lập môi trưng**, và **biên dịch thử** một ứng dụng với toolchain chéo.\n\n---\n\n## 1) SDK trong Yocto là gì?\n**SDK (Software Development Kit)** cung cấp:\n\n- **Cross toolchain**: biên dịch trên host (x86_64) ra binary cho **RPi4 (ARM64)**.  \n- **Sysroots**: header & thư viện tương ứng.  \n- **Script thiết lập môi trưng**: đặt biến `PATH`, `CC`, `CXX`, `PKG_CONFIG_PATH`, v.v.\n\n> Với **Raspberry Pi 4**, khuyến nghị dùng máy 64-bit và **MACHINE = `raspberrypi4-64`** để nhận **toolchain aarch64**.\n\n---\n\n## 2) Chuẩn bị dự án Yocto cho RPi 4\nTạo workspace và clone các layer (ví dụ nhánh *dunfell* để đồng bộ hướng dẫn):\n\n```bash\nmkdir -p ~/yocto && cd ~/yocto\n\n# Poky (dunfell ví dụ)\ngit clone -b dunfell git://git.yoctoproject.org/poky\ncd poky\n\n# Layer Raspberry Pi + OpenEmbedded\ngit clone -b dunfell git://git.yoctoproject.org/meta-raspberrypi\ngit clone -b dunfell git://git.openembedded.org/meta-openembedded\n\n# Thiết lập môi trưng build\nsource oe-init-build-env\n```\n\nCập nhật **`conf/bblayers.conf`** để thêm layer:\n```conf\nBBLAYERS ?= \" \\\n  /home/<user>/yocto/poky/meta \\\n  /home/<user>/yocto/poky/meta-poky \\\n  /home/<user>/yocto/poky/meta-yocto-bsp \\\n  /home/<user>/yocto/poky/meta-raspberrypi \\\n  /home/<user>/yocto/poky/meta-openembedded/meta-oe \\\n\"\n```\n> ổi `<user>` cho phù hợp đưng dẫn máy bạn.\n\nCập nhật **`conf/local.conf`** (phần quan trng):\n```conf\nMACHINE ?= \"raspberrypi4-64\"   # ARM64 cho Raspberry Pi 4\nPACKAGE_CLASSES ?= \"package_rpm\"\n# (tuỳ chn) tối ưu dung lượng: INHERIT += \"rm_work\"\n```\n\n---\n\n## 3) Các cách **tạo SDK**\n\n### Cách A — Thêm toolchain vào **image** (phát triển **trực tiếp trên target**)\nTrong `conf/local.conf`:\n```conf\nEXTRA_IMAGE_FEATURES ?= \"tools_sdk\"\n```\nRồi build image:\n```bash\nbitbake core-image-minimal\n```\n> Cách này cài **gcc/make/headers** vào **Raspberry Pi 4**. Phù hợp demo nhanh trên target nhưng **không khuyến nghị** cho sản xuất do giới hạn tài nguyên.\n\n### Cách B — Tạo **Standard SDK** (khuyến nghị)\nTạo **file cài đặt SDK** trên host:\n```bash\nbitbake core-image-minimal -c populate_sdk\n```\nSau khi xong, tìm trong:\n```\nbuild/tmp/deploy/sdk/\n```\nBạn sẽ thấy file dạng:\n```\npoky-glibc-x86_64-core-image-minimal-*-raspberrypi4-64-toolchain-<ver>.sh\n```\n> Tên thật có thể khác đôi chút theo cấu hình. Cứ dựa **mẫu có `raspberrypi4-64`** là đúng.\n\n### Cách C — Tạo **Extensible SDK (eSDK)**\n```bash\nbitbake core-image-minimal -c populate_sdk_ext\n```\n**eSDK** bao gồm devtool và metadata, tiện cho việc **sửa recipe, thử nghiệm, cập nhật** ngay trên host.\n\n---\n\n## 4) Cài đặt & Thiết lập môi trưng SDK trên host\n\n### 4.1 Cài đặt\nChạy script `.sh` trong thư mục `deploy/sdk`:\n```bash\ncd build/tmp/deploy/sdk/\n./poky-glibc-x86_64-core-image-minimal-*-raspberrypi4-64-toolchain-*.sh\n```\n- Chn nơi cài (mặc định thưng là `/opt/poky/<ver>`).\n\n### 4.2 Nạp biến môi trưng (quan trng)\nTìm **script environment** cho **aarch64** rồi `source`:\n```bash\n# gợi ý tìm nhanh\nls /opt/poky/*/environment-setup-*aarch64*\n\n# ví dụ (tên thực tế có thể khác nhau)\nsource /opt/poky/3.1.33/environment-setup-aarch64-poky-linux\n```\nKiểm tra nhanh:\n```bash\necho \"$CC\"\n$CC --version\n```\nBạn nên thấy toolchain **`aarch64-poky-linux-gcc`**.\n\n---\n\n## 5) Thử nghiệm SDK bằng ứng dụng C đơn giản\n\n### 5.1 Viết mã nguồn\nTạo file `~/hello_SDK.c`:\n```c\n#include <stdio.h>\n\nint main(void) {\n    printf(\"thanhdeptrai: hello SDK for Raspberry Pi 4 (aarch64)!\\n\");\n    return 0;\n}\n```\n\n### 5.2 Biên dịch bằng cross toolchain\n```bash\n# ảm bảo bạn đã 'source environment-setup-aarch64-poky-linux'\n$CC -o ~/hello_SDK_app ~/hello_SDK.c\n```\n\n### 5.3 Chép và chạy trên target\n**Cách 1 — SSH tới Raspberry Pi 4 thực tế**\n```bash\n# thay 192.168.x.x là IP của Pi 4\nscp ~/hello_SDK_app root@192.168.x.x:/home/root/\nssh root@192.168.x.x\n/home/root/hello_SDK_app\n```\n**Cách 2 — Nếu bạn đang dùng QEMU aarch64**\n```bash\nscp ~/hello_SDK_app root@<qemu-ip>:/home/root/\nssh root@<qemu-ip> /home/root/hello_SDK_app\n```\n\nKết quả mong đợi:\n```\nthanhdeptrai: hello SDK for Raspberry Pi 4 (aarch64)!\n```\n\n---\n\n## 6) Mẹo & Tùy biến SDK\n\n- **Chn image khác**: SDK phụ thuộc vào image (ví dụ `core-image-sato` nếu cần đồ ha).\n- **Thêm gói vào SDK** (khi tạo):\n  ```conf\n  # conf/local.conf hoặc distro/layer\n  TOOLCHAIN_TARGET_TASK += \" packageA packageB \"\n  TOOLCHAIN_HOST_TASK   += \" nativesdk-cmake nativesdk-pkgconfig \"\n  ```\n- **eSDK + devtool**: tiện cho quy trình chỉnh sửa recipe, `devtool modify`, `devtool build`, `devtool update-recipe` ngay trên host.\n\n---\n\n## 7) Lợi ích chính khi dùng SDK\n- **Nhanh & gn**: Không phải rebuild toàn bộ image khi chỉnh ứng dụng.  \n- **Nhất quán**: Toolchain/headers giống target → ít lỗi “khác môi trưng.  \n- **Thân thiện IDE**: Dùng VS Code, CLion… với toolchain aarch64.  \n- **Tiết kiệm tài nguyên target**: Build trên host, không làm nặng Pi 4.\n\n---\n\n## 8) Tóm tắt nhanh các lệnh quan trng\n\n```bash\n# Chuẩn bị & cấu hình cho RPi4 (ARM64)\nsource oe-init-build-env\n# (sửa local.conf: MACHINE ?= \"raspberrypi4-64\")\n\n# Tạo SDK chuẩn\nbitbake core-image-minimal -c populate_sdk\n\n# Tạo eSDK\nbitbake core-image-minimal -c populate_sdk_ext\n\n# Cài đặt SDK\ncd build/tmp/deploy/sdk/\n./poky-glibc-x86_64-core-image-minimal-*-raspberrypi4-64-toolchain-*.sh\n\n# Nạp môi trưng cross-compile\nsource /opt/poky/*/environment-setup-aarch64-poky-linux\n\n# Build app mẫu\n$CC -o ~/hello_SDK_app ~/hello_SDK.c\n```\n\n---\n\n### Ghi chú tương thích\n- Ví dụ nhánh **dunfell (3.1.x)** phổ biến với cộng đồng RPi, nhưng bạn có thể dùng bản mới hơn (kirkstone/nanbield...) miễn layer tương thích.  \n- Tên file SDK `.sh` và script `environment-setup-*` **có thể khác** theo **distro/TCLIBC/MACHINE**; dùng `ls` để dò đúng tên.\n\nChúc bạn build SDK thành công và code “mượt cho **Raspberry Pi 4**! 🚀\n"}, {"id": "content/8-build-image-cho-raspberry-pi-4.md", "title": "Xây dựng Image cho **Raspberry Pi 4** với Yocto Project", "body": "# Xây dựng Image cho **Raspberry Pi 4** với Yocto Project\n\nYocto Project là một công cụ mạnh mẽ cho phép tạo ra các hệ thống Linux tùy chỉnh cho các thiết bị nhúng. Tài liệu này hướng dẫn bạn xây dựng **image hoàn chỉnh cho Raspberry Pi 4** (1/2/4/8GB).\n\n---\n\n## 1. Chuẩn bị môi trường\n\n### 1.1. Yêu cầu phần cứng và phần mềm\nTrước khi bắt đầu, hãy đảm bảo bạn có:\n- **Máy host**: Ubuntu (khuyến nghị chạy trên VMware/metal) với **≥ 100GB** trống.\n- **Thiết bị**: **Raspberry Pi 4**.\n- **Bộ nhớ**: thẻ **microSD ≥ 16GB** (khuyến nghị UHS-I/SDHC tốt).\n- **Kết nối Internet**: tải package và source code.\n\n### 1.2. Cài đặt các package cần thiết (Ubuntu/Debian)\n```bash\nsudo apt update\nsudo apt install gawk wget git diffstat unzip texinfo gcc build-essential chrpath socat \\\n  cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\n  python3-git python3-jinja2 python3-subunit zstd liblz4-tool file locales libacl1\n```\n\n> Nếu dùng Fedora/CentOS, bạn có thể cài các gói tương đương theo distro đó.\n\n---\n\n## 2. Thiết lập môi trường Yocto\n\n### 2.1. Tải các meta-layer cần thiết\nTrong ví dụ này dùng nhánh **dunfell** để đồng bộ với các hướng dẫn cổ điển (bạn có thể chọn nhánh khác đồng bộ giữa tất cả layer).\n\n```bash\nmkdir -p ~/yocto\ncd ~/yocto\n\n# Poky (Yocto reference distro)\ngit clone -b dunfell git://git.yoctoproject.org/poky\ncd poky\n\n# Layer cho Raspberry Pi\ngit clone -b dunfell git://git.yoctoproject.org/meta-raspberrypi\n\n# OpenEmbedded layer bổ sung\ngit clone -b dunfell git://git.openembedded.org/meta-openembedded\n```\n\n### 2.2. Khởi tạo môi trường build\n```bash\ncd ~/yocto/poky\nsource oe-init-build-env\n```\nSau lệnh trên, thư mục **build/** và các file cấu hình sẽ được tạo.\n\n### 2.3. Cấu hình build\n\n#### 2.3.1. Sửa `conf/local.conf`\nMở `build/conf/local.conf` và điều chỉnh:\n```conf\n# Chọn máy đích: Raspberry Pi 4 (ARM64)\nMACHINE ??= \"raspberrypi4-64\"\n\n# (Tuỳ chọn) tiết kiệm dung lượng, xóa work sau khi hoàn tất\nINHERIT += \"rm_work\"\n\n# (Tuỳ chọn) thêm công cụ tiện ích khi debug\nEXTRA_IMAGE_FEATURES ?= \"debug-tweaks\"\n\n# (Tuỳ chọn) Wi-Fi/Bluetooth & firmware thường dùng trên RPi4\n# IMAGE_INSTALL:append = \" linux-firmware-brcm43455 pi-bluetooth iw wpa-supplicant bluez5\"\n```\n\n#### 2.3.2. Thêm meta-layer vào `conf/bblayers.conf`\nBổ sung **meta-raspberrypi** và **meta-openembedded/meta-oe** (chỉnh sửa đường dẫn theo máy của bạn):\n```conf\nBBLAYERS ?= \" \\\n  /home/<user>/yocto/poky/meta \\\n  /home/<user>/yocto/poky/meta-poky \\\n  /home/<user>/yocto/poky/meta-yocto-bsp \\\n  /home/<user>/yocto/poky/meta-raspberrypi \\\n  /home/<user>/yocto/poky/meta-openembedded/meta-oe \\\n\"\n```\n> Thay `</user>` bằng tên người dùng/đường dẫn thực tế.\n\n---\n\n## 3. Build và flash image\n\n### 3.1. Tiến hành build\nVí dụ build image có giao diện **Sato** (bạn có thể dùng `core-image-minimal` nếu muốn console tối giản):\n```bash\ncd ~/yocto/poky\nbitbake core-image-sato\n```\n> Thời gian build phụ thuộc CPU/RAM/SSD/Mạng. Lần đầu có thể lâu; các lần sau nhanh hơn nhờ sstate-cache.\n\n### 3.2. Vị trí image đầu ra\nSau khi build xong, image được đặt tại:\n```\n~/yocto/poky/build/tmp/deploy/images/raspberrypi4-64/\n```\n\n### 3.3. Flash image vào thẻ nhớ\n\n**(1) Xác định thiết bị thẻ nhớ**\n```bash\nlsblk\n```\n\n**(2) Giải nén image và ghi vào thẻ**\nVí dụ với file `.wic.bz2` sinh ra từ bước build:\n```bash\ncd ~/yocto/poky/build/tmp/deploy/images/raspberrypi4-64/\n\n# Chọn đúng file .wic.bz2 của bạn\ncp core-image-sato-raspberrypi4-64-*.wic.bz2 temp.wic.bz2\nbzip2 -d temp.wic.bz2\n\n# CẢNH BÁO: thay /dev/sdX bằng thiết bị thẻ nhớ CHÍNH XÁC! (ví dụ /dev/sdb)\nsudo dd if=temp.wic of=/dev/sdX bs=4M status=progress conv=fsync\nsync\n```\n\n> (Khuyến nghị) Nếu có file `.bmap`, dùng **bmaptool** sẽ nhanh hơn và an toàn hơn:\n> ```bash\n> sudo apt install bmap-tools\n> sudo bmaptool copy core-image-sato-raspberrypi4-64-*.wic.bz2 /dev/sdX\n> ```\n\n### 3.4. Khởi động Raspberry Pi 4\n- Cắm thẻ microSD vào **Raspberry Pi 4**, cấp nguồn.\n- Kết nối **HDMI** (để xem đồ họa) hoặc **UART/SSH** (image console).\n- Nếu bật `debug-tweaks`, thường có thể đăng nhập `root` (không mật khẩu) ở tty cục bộ.\n- (Tuỳ chọn) Cấu hình Wi‑Fi với `wpa_supplicant`:\n  ```bash\n  # Ví dụ nhanh:\n  cat <<'EOF' > /etc/wpa_supplicant/wpa_supplicant.conf\n  ctrl_interface=/var/run/wpa_supplicant\n  update_config=1\n  country=US\n\n  network={\n      ssid=\"Ten_WIFI\"\n      psk=\"Mat_khau_WIFI\"\n      key_mgmt=WPA-PSK\n  }\n  EOF\n\n  # Kích hoạt (tuỳ theo init system của image)\n  wpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant/wpa_supplicant.conf\n  udhcpc -i wlan0  # hoặc dhclient, hoặc systemd-networkd tùy image\n  ```\n\n---\n\n## 4. Kết luận\nVới hướng dẫn này, bạn đã chuyển từ hướng dẫn dành cho **Raspberry Pi Zero W** sang **Raspberry Pi 4**:\n- Thiết lập meta-layer phù hợp (**meta-raspberrypi**, **meta-openembedded**)\n- Cấu hình `MACHINE ??= \"raspberrypi4-64\"`\n- Build image (**core-image-sato** hoặc **core-image-minimal**)\n- Flash và khởi động trên phần cứng thực\n\nBạn có thể tiếp tục tuỳ biến image, thêm package/firmware, hoặc tích hợp CI/CD theo nhu cầu dự án.\n"}, {"id": "content/9-quy-tr-nh-ph-t-tri-n-kernel-trong-yocto-project.md", "title": "Phát triển Kernel cho **Raspberry Pi 4** với Yocto Project (core-image-sato)", "body": "# Phát triển Kernel cho **Raspberry Pi 4** với Yocto Project (core-image-sato)\n\nPhát triển và tùy chỉnh kernel Linux là một nhiệm vụ quan trng trong hệ thống nhúng. Yocto Project cung cấp quy trình có cấu trúc để quản lý, vá (patch), tùy biến và build kernel cho thiết bị. Tài liệu này hướng dẫn **thêm một kernel module mẫu** để điu khiển LED qua GPIO27 trên **Raspberry Pi 4 (BCM2711, 64-bit)** và tích hợp vào image **`core-image-sato`**.\n\n> 💡 Yêu cầu: bạn đã có môi trưng Yocto với `meta-raspberrypi` và đang build cho **MACHINE = raspberrypi4-64**.\n\n---\n\n## 1) Tổng quan Kernel trong Yocto\n\nTrong Yocto, kernel được build thông qua **recipe** (đặt trong `meta/*/recipes-kernel/linux/`). Có vài nguồn/kernel base thưng dùng:\n\n* **Kernel chuẩn** từ kernel.org\n* **Kernel nhà cung cấp** (ví dụ Raspberry Pi Foundation)\n* **Kernel tùy chỉnh** (fork/nhánh riêng)\n\nYocto khuyến khích quản lý thay đổi kernel bằng **patch** (git) và/hoặc **config fragment**, nhằm đảm bảo khả năng tái tạo (reproducibility).\n\n---\n\n## 2) Quy trình tích hợp module mẫu (GPIO27)\n\nMục tiêu: thêm module **`mgpio`** để set GPIO27 **HIGH** khi nạp module, và **LOW** khi remove.\n\n### 2.1) Cấu trúc module\n\n```\nmgpio/\n├── Kconfig\n├── Makefile\n└── mgpio.c\n```\n\n**`mgpio.c`**\n\n```c\n#include <linux/module.h>\n#include <linux/gpio.h>\n\n#define GPIO_NUMBER_27  27\n#define LOW  0\n#define HIGH 1\n\nstatic int __init mgpio_driver_init(void)\n{\n    /* Cấp quyn và set GPIO27 làm output */\n    gpio_request(GPIO_NUMBER_27, \"gpio_27\");\n    gpio_direction_output(GPIO_NUMBER_27, LOW);\n\n    /* Set GPIO27 HIGH */\n    gpio_set_value(GPIO_NUMBER_27, HIGH);\n    pr_info(\"mgpio: GPIO27 set to HIGH, status: %d\\n\", gpio_get_value(GPIO_NUMBER_27));\n    return 0;\n}\n\nstatic void __exit mgpio_driver_exit(void)\n{\n    /* Trả GPIO27 v LOW trước khi ri */\n    gpio_set_value(GPIO_NUMBER_27, LOW);\n    gpio_free(GPIO_NUMBER_27);\n    pr_info(\"mgpio: GPIO27 set to LOW (module exit)\\n\");\n}\n\nmodule_init(mgpio_driver_init);\nmodule_exit(mgpio_driver_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"thanhdeptrai\");\nMODULE_DESCRIPTION(\"GPIO Driver for Raspberry Pi 4 (BCM2711)\");\n```\n\n**`Makefile`**\n\n```make\nEXTRA_CFLAGS = -Wall\nobj-$(CONFIG_MGPIO) = mgpio.o\n```\n\n**`Kconfig`**\n\n```Kconfig\nmenu \"mgpio device driver\"\n\nconfig MGPIO\n    tristate \"mgpio device driver\"\n    depends on ARM64 || ARM\n    help\n      Simple demo driver: set GPIO27 HIGH on load, LOW on unload.\n\nendmenu\n```\n\n> 📌 Lưu ý: Trên kernel mới API GPIO legacy có thể đã bị cảnh báo/khuyên dùng gpiod.  đây dùng API cũ cho mục đích demo tối giản.\n\n---\n\n### 2.2) Thiết lập môi trưng\n\n```bash\n# Trong cây nguồn Poky\nsource oe-init-build-env\n\n# ảm bảo MACHINE là Raspberry Pi 4 (64-bit)\n# poky/build/conf/local.conf\n# MACHINE ?= \"raspberrypi4-64\"\n```\n\n---\n\n### 2.3) Trích xuất nguồn kernel bằng devtool\n\n```bash\ncd ~/yocto/poky/build\ndevtool modify virtual/kernel\n```\n\n* Mã nguồn kernel sẽ xuất hiện ở:\n  `build/workspace/sources/linux-raspberrypi`\n\nTạo thư mục module và thêm 3 file ở trên:\n\n```bash\ncd workspace/sources/linux-raspberrypi\nmkdir -p drivers/mgpio\n# đặt Kconfig, Makefile, mgpio.c vào drivers/mgpio/\n```\n\n---\n\n### 2.4) Khai báo module với kernel tree\n\n**Sửa `drivers/Makefile`** (thêm dòng này cuối file):\n\n```make\nobj-$(CONFIG_MGPIO) += mgpio/\n```\n\n**Sửa `drivers/Kconfig`** (thêm dòng này cuối file):\n\n```Kconfig\nsource \"drivers/mgpio/Kconfig\"\n```\n\n---\n\n### 2.5) Bật cấu hình module trong defconfig\n\nối với **Raspberry Pi 4 / ARM64**, cập nhật defconfig tương ứng (thưng là **`arch/arm64/configs/bcm2711_defconfig`**):\n\n```diff\n+ CONFIG_MGPIO=m\n```\n\n> Nếu dự án của bạn dùng defconfig tên khác, hãy chỉnh đúng file dưới `arch/arm64/configs/…`.\n> (Cách thay thế nâng cao: dùng **config fragment** thay vì sửa defconfig trực tiếp.)\n\n---\n\n### 2.6) Tạo patch từ thay đổi\n\n```bash\ncd workspace/sources/linux-raspberrypi\ngit add drivers/mgpio/ drivers/Kconfig drivers/Makefile arch/arm64/configs/bcm2711_defconfig\ngit commit -m \"Add mgpio driver (GPIO27) for Raspberry Pi 4 (BCM2711)\"\ngit format-patch -1\n```\n\nPatch vừa tạo có dạng `0001-Add-mgpio-driver-….patch`.\n\n---\n\n### 2.7) ưa patch vào meta-layer của bạn\n\nTạo thư mục trong layer tùy chỉnh, ví dụ `meta-thanhdeptrai`:\n\n```bash\nmkdir -p ../../meta-thanhdeptrai/recipes-kernel/linux/linux-raspberrypi\ncp 0001-Add-mgpio-driver-*.patch ../../meta-thanhdeptrai/recipes-kernel/linux/linux-raspberrypi/\n```\n\nTạo **`linux-raspberrypi_%.bbappend`**:\n\n```\nmeta-thanhdeptrai/\n└── recipes-kernel/\n    └── linux/\n        ├── linux-raspberrypi/\n        │   └── 0001-Add-mgpio-driver-*.patch\n        └── linux-raspberrypi_%.bbappend\n```\n\n**`linux-raspberrypi_%.bbappend`**\n\n```bitbake\nFILESEXTRAPATHS:prepend := \"${THISDIR}/${PN}:\"\n\n# Thêm patch vào SRC_URI\nSRC_URI += \"file://0001-Add-mgpio-driver-*.patch\"\n\n# Tự động nạp module khi boot (tùy chn)\nKERNEL_MODULE_AUTOLOAD += \"mgpio\"\n```\n\n---\n\n### 2.8) Build kernel (và/hoặc image)\n\n```bash\n# Chỉ build kernel\nbitbake virtual/kernel\n\n# Hoặc build image mục tiêu (tự kéo kernel mới)\nbitbake core-image-sato\n```\n\nSau khi build image, flash ra thẻ microSD như bình thưng. Nếu dùng `KERNEL_MODULE_AUTOLOAD`, module **mgpio** sẽ tự load khi khởi động (GPIO27 sẽ ở mức HIGH). Nếu không, có thể thử thủ công:\n\n```bash\n# Trên thiết bị:\nmodprobe mgpio\ndmesg | tail -n 50\n# ... kiểm tra log \"GPIO27 set to HIGH ...\"\nrmmod mgpio\n```\n\n---\n\n## 3) Kết luận\n\nBạn vừa thêm một **kernel module tùy chỉnh** vào kernel **Raspberry Pi 4 (BCM2711, ARM64)** trong Yocto bằng quy trình tiêu chuẩn:\n\n* Sửa code trong **workspace** qua `devtool modify virtual/kernel`\n* Commit và **tạo patch**\n* Thêm **.bbappend** + **patch** vào **meta-layer** riêng\n* Build lại **kernel/image**\n\nCách làm này đảm bảo thay đổi được quản lý sạch sẽ, **tái tạo được** và dễ chia sẻ trong nhóm. Từ ví dụ `mgpio`, bạn có thể mở rộng để tích hợp driver thật của dự án, thêm config fragments, hoặc chia nh patch theo best practices.\n"}]